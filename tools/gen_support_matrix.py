

#!/usr/bin/env python3
"""Generate support matrix from YAML into RST (and optional Markdown).

- Canonical source: docs/support/actual-support-matrix.yml
- Outputs:
  * docs/support/actual-support-matrix.rst  (for Sphinx)
  * docs/support/actual-support-matrix.md   (optional convenience for GitHub)

Exit codes:
  0 on success, 2 on schema/validation problems, 3 when PyYAML is missing.
"""
from __future__ import annotations

import datetime
import sys
from pathlib import Path

try:
    import yaml  # type: ignore
except Exception:
    sys.stderr.write(
        "ERROR: PyYAML is required. Install with `pip install pyyaml` or add to your env.\n"
    )
    sys.exit(3)

SRC = Path("docs/support/actual-support-matrix.yml")
RST = Path("docs/support/actual-support-matrix.rst")
MD  = Path("docs/support/actual-support-matrix.md")  # optional

NOW_UTC = datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")


def _semver_key(version: str) -> tuple[int, int, int]:
    parts = [p for p in str(version).split(".") if p != ""]
    try:
        nums = [int(p) for p in parts[:3]]
    except ValueError:
        nums = [0, 0, 0]
    while len(nums) < 3:
        nums.append(0)
    return tuple(nums)  # type: ignore[return-value]


def _load_yaml(src: Path) -> dict:
    if not src.exists():
        sys.stderr.write(f"ERROR: missing source YAML: {src}\n")
        sys.exit(2)
    try:
        data = yaml.safe_load(src.read_text(encoding="utf-8")) or {}
    except Exception as e:
        sys.stderr.write(f"ERROR: failed to parse YAML: {e}\n")
        sys.exit(2)

    if not isinstance(data, dict):
        sys.stderr.write("ERROR: YAML root must be a mapping.\n")
        sys.exit(2)

    # minimal schema checks
    if "schema_version" not in data:
        sys.stderr.write("ERROR: YAML missing `schema_version`.\n")
        sys.exit(2)
    if "releases" not in data:
        data["releases"] = []

    if not isinstance(data["releases"], list):
        sys.stderr.write("ERROR: `releases` must be a list.\n")
        sys.exit(2)

    return data


def _sorted_rows(releases: list[dict]) -> list[dict]:
    # Sort newest first by semver, then by release_date
    def key(row: dict):
        return (_semver_key(row.get("version", "0.0.0")), row.get("release_date", "0000-00-00"))

    rows = list(releases)
    rows.sort(key=key, reverse=True)
    return rows


def _render_rst(rows: list[dict]) -> str:
    header = (
        "Actual Sync Server — Support Matrix\n" +
        "=" * 35 + "\n\n" +
        f".. note:: AUTO-GENERATED from YAML on {NOW_UTC}. Do not edit this file by hand.\n\n" +
        "Policy: Current + 10 prior stable releases (pre-releases excluded). Engines mismatch = warn (ADR-018).\n\n" +
        ".. list-table::\n   :header-rows: 1\n   :widths: 12 14 14 18 10 12 30\n\n" +
        "   * - Version\n     - Release date\n     - engines.node\n     - Tested on (UTC)\n     - Result\n     - Status\n     - Notes\n"
    )
    body_lines = []
    if not rows:
        body_lines.append(
            "   * - N/A\n     - N/A\n     - N/A\n     - N/A\n     - N/A\n     - supported\n     - Seed row; populate by updating the YAML and regenerating.\n"
        )
    else:
        for r in rows:
            notes = (r.get("notes", "") or "").replace("\n", " ")
            body_lines.append(
                f"   * - {r.get('version','')}\n"
                f"     - {r.get('release_date','')}\n"
                f"     - {r.get('engines_node','')}\n"
                f"     - {r.get('tested_on','')}\n"
                f"     - {r.get('result','')}\n"
                f"     - {r.get('status','')}\n"
                f"     - {notes}\n"
            )
    return header + "".join(body_lines)


def _render_md(rows: list[dict]) -> str:
    lines = [
        "# Actual Sync Server — Support Matrix\n",
        f"_AUTO-GENERATED from YAML on {NOW_UTC}. Do not edit this file by hand._\n\n",
        "**Policy:** Current + 10 prior stable releases (pre-releases excluded). Engines mismatch = warn (ADR-018).\n\n",
        "| Version | Release date | engines.node | Tested on (UTC) | Result | Status | Notes |\n",
        "|--------:|--------------|--------------|------------------|--------|--------|-------|\n",
    ]
    if not rows:
        lines.append("| N/A | N/A | N/A | N/A | N/A | supported | Seed row; update YAML and regenerate. |\n")
    else:
        for r in rows:
            notes = (r.get("notes", "") or "").replace("\n", " ")
            lines.append(
                "| {version} | {release_date} | {engines_node} | {tested_on} | {result} | {status} | {notes} |\n".format(
                    version=r.get("version", ""),
                    release_date=r.get("release_date", ""),
                    engines_node=r.get("engines_node", ""),
                    tested_on=r.get("tested_on", ""),
                    result=r.get("result", ""),
                    status=r.get("status", ""),
                    notes=notes,
                )
            )
    return "".join(lines)


def main() -> int:
    data = _load_yaml(SRC)
    rows = _sorted_rows(data.get("releases", []))

    rst = _render_rst(rows)
    RST.write_text(rst, encoding="utf-8")

    md = _render_md(rows)
    MD.write_text(md, encoding="utf-8")

    print(f"Generated {RST} and {MD}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())