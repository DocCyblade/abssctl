#!/usr/bin/env python3
"""Generate support matrix documents from the YAML source of truth."""
from __future__ import annotations

import sys
from datetime import UTC, datetime
from pathlib import Path

try:
    import yaml  # type: ignore
except Exception:
    sys.stderr.write(
        "ERROR: PyYAML is required. Install with `pip install pyyaml` or add to your env.\n"
    )
    sys.exit(3)

SRC = Path("docs/support/actual-support-matrix.yml")
RST = Path("docs/support/actual-support-matrix.rst")
MD = Path("docs/support/actual-support-matrix.md")  # optional

NOW_UTC = datetime.now(UTC).strftime("%Y-%m-%d %H:%M:%S UTC")


def _semver_key(version: str) -> tuple[int, int, int]:
    """Return a tuple that sorts semantic version strings newest-first."""
    parts = [p for p in str(version).split(".") if p]
    try:
        nums = [int(p) for p in parts[:3]]
    except ValueError:
        nums = [0, 0, 0]
    while len(nums) < 3:
        nums.append(0)
    return tuple(nums)  # type: ignore[return-value]


def _load_yaml(src: Path) -> dict:
    """Load the YAML support matrix, applying minimal schema validation."""
    if not src.exists():
        sys.stderr.write(f"ERROR: missing source YAML: {src}\n")
        sys.exit(2)
    try:
        data = yaml.safe_load(src.read_text(encoding="utf-8")) or {}
    except Exception as exc:  # pragma: no cover - defensive error path
        sys.stderr.write(f"ERROR: failed to parse YAML: {exc}\n")
        sys.exit(2)

    if not isinstance(data, dict):
        sys.stderr.write("ERROR: YAML root must be a mapping.\n")
        sys.exit(2)

    if "schema_version" not in data:
        sys.stderr.write("ERROR: YAML missing `schema_version`.\n")
        sys.exit(2)

    releases = data.setdefault("releases", [])
    if not isinstance(releases, list):
        sys.stderr.write("ERROR: `releases` must be a list.\n")
        sys.exit(2)

    return data


def _sorted_rows(releases: list[dict]) -> list[dict]:
    """Return releases sorted newest-first by semver, then by release date."""

    def key(row: dict) -> tuple[tuple[int, int, int], str]:
        return (
            _semver_key(row.get("version", "0.0.0")),
            row.get("release_date", "0000-00-00"),
        )

    rows = list(releases)
    rows.sort(key=key, reverse=True)
    return rows


def _render_rst(rows: list[dict]) -> str:
    """Render the reStructuredText table."""
    header_lines = [
        "Actual Sync Server — Support Matrix",
        "=" * 35,
        "",
        f".. note:: AUTO-GENERATED from YAML on {NOW_UTC}. Do not edit this file by hand.",
        "",
        "Policy: Current + 10 prior stable releases (pre-releases excluded).",
        "Engines mismatch = warn (ADR-018).",
        "",
        ".. list-table::",
        "   :header-rows: 1",
        "   :widths: 12 14 14 18 10 12 30",
        "",
        "   * - Version",
        "     - Release date",
        "     - engines.node",
        "     - Tested on (UTC)",
        "     - Result",
        "     - Status",
        "     - Notes",
    ]

    body_lines: list[str] = []
    if not rows:
        body_lines.append(
            "   * - N/A\n"
            "     - N/A\n"
            "     - N/A\n"
            "     - N/A\n"
            "     - N/A\n"
            "     - supported\n"
            "     - Seed row; populate by updating the YAML and regenerating.\n"
        )
    else:
        for entry in rows:
            notes = (entry.get("notes", "") or "").replace("\n", " ")
            body_lines.append(
                f"   * - {entry.get('version', '')}\n"
                f"     - {entry.get('release_date', '')}\n"
                f"     - {entry.get('engines_node', '')}\n"
                f"     - {entry.get('tested_on', '')}\n"
                f"     - {entry.get('result', '')}\n"
                f"     - {entry.get('status', '')}\n"
                f"     - {notes}\n"
            )

    header = "\n".join(header_lines) + "\n"
    return header + "".join(body_lines)


def _render_md(rows: list[dict]) -> str:
    """Render the Markdown table variant."""
    lines = [
        "# Actual Sync Server — Support Matrix\n",
        f"_AUTO-GENERATED from YAML on {NOW_UTC}. Do not edit this file by hand._\n\n",
        "**Policy:** Current + 10 prior stable releases (pre-releases excluded).\n",
        "Engines mismatch = warn (ADR-018).\n\n",
        "| Version | Release date | engines.node | Tested on (UTC) | Result | Status | Notes |\n",
        "|--------:|--------------|--------------|------------------|--------|--------|-------|\n",
    ]
    if not rows:
        lines.append(
            "| N/A | N/A | N/A | N/A | N/A | supported | Seed row; update YAML and regenerate. |\n"
        )
    else:
        for entry in rows:
            notes = (entry.get("notes", "") or "").replace("\n", " ")
            line_template = (
                "| {version} | {release_date} | {engines_node} | {tested_on} | "
                "{result} | {status} | {notes} |\n"
            )
            lines.append(
                line_template.format(
                    version=entry.get("version", ""),
                    release_date=entry.get("release_date", ""),
                    engines_node=entry.get("engines_node", ""),
                    tested_on=entry.get("tested_on", ""),
                    result=entry.get("result", ""),
                    status=entry.get("status", ""),
                    notes=notes,
                )
            )
    return "".join(lines)


def main() -> int:
    """Generate RST and Markdown support matrices from the YAML source."""
    data = _load_yaml(SRC)
    rows = _sorted_rows(data.get("releases", []))

    rst = _render_rst(rows)
    RST.write_text(rst, encoding="utf-8")

    md = _render_md(rows)
    MD.write_text(md, encoding="utf-8")

    sys.stdout.write(f"Generated {RST} and {MD}\n")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
